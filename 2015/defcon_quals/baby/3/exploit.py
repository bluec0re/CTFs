#!/usr/bin/env python
# encoding: utf-8

import socket
import re
import requests
import bs4
import os

s = socket.create_connection(('mathwhiz_c951d46fed68687ad93a84e702800b7a.quals.shallweplayaga.me', 21249))


def recvline(s, end=b'\n'):
    line = b''
    try:
        while True:
            c = s.recv(1)
            if c in end:
                return line
            if c == b'':
                return line
            line += c
    except KeyboardInterrupt:
        print(line)
        raise


def getprime(n):
    with open('primes-to-100k.txt') as fp:
        for i, line in enumerate(fp):
            current = int(line)
            if i == n-1:
                return current

REPLACEMENTS = {
    'ONE': '1',
    'TWO': '2',
    'THREE': '3',
    'FOUR': '4',
    'FIVE': '5',
    'SIX': '6',
    'SEVEN': '7',
    'EIGHT': '8',
    'NINE': '9',
    'ZERO': '0',
    '^': '**',
    '{': '(',
    '}': ')',
    '[': '(',
    ']': ')',
}

while True:
    line = s.recv(1024)
    try:
        line = line.decode()
    except:
        try:
            line = line.decode('latin1')
        except:
            print(line)
            break

    for k, v in REPLACEMENTS.items():
        line = line.replace(k, v)
    if not re.search('^[0-9.+/*\(\)-= ]+$', line):
        print("Something goes wrong!: {}".format(line))
        break
    result = eval(line.replace('=', ''))
    print("{} {}".format(line.trim(), result))
    s.send(str(result).encode() + b"\n")

#for i in range(3):
#    print(recvline(s))
#line = recvline(s, b":")
#m = re.search(b'n = (\d+)', line)
#PRIME_CNT = 10
#if m:
#    n = int(m.group(1))
#    print("n = {}".format(n))
#    result = "{}".format(getprime(n)).encode()
#    print(result)
#    s.send(result + b"\n")
#for i in range(3):
#    print(recvline(s))
#
#
#def fib(a, b, n):
#    if n == 0:
#        return 0
#    if n == 1:
#        return 1
#    c = a
#    for i in range(n-1):
#        c = a+b
#        a = b
#        b = c
#    return c
#
#
#def binomial(n, k):
#    c = [0] * (n + 1)
#    c[0] = 1
#    for i in range(1, n + 1):
#        c[i] = 1
#        j = i - 1
#        while j > 0:
#            c[j] += c[j - 1]
#            j -= 1
#    return c[k]
#
#
#for i in range(10):
#    print("f({}) = {}".format(i, fib(0, 1, i)))
#
#line = recvline(s, b":")
#m = re.search(b'n = (\d+)', line)
#if m:
#    n = int(m.group(1))
#    print("n = {}".format(n))
#    f = fib(0, 1, n)
#    print("f({}) = {}".format(n, f))
#    s.send("{}\n".format(f).encode())
#
#for i in range(3):
#    print(recvline(s))
#
#line = recvline(s, b":")
#m = re.search(b'n = (\d+)', line)
#if m:
#    n = int(m.group(1))
#    print("n = {}".format(n))
#    with open('b000055.txt') as fp:
#        for i, line in enumerate(fp):
#            idx, current = tuple(map(int, line.split()))
#            if idx == n:
#                result = current
#                break
#
#    s.send("{}\n".format(result).encode())
#
#last_cache = ''
#def getSolutions(seq, desc):
#    global last_cache
#    last_cache = "cache/{}.txt".format(desc[:200].replace('/', '_'))
#    if os.path.exists(last_cache):
#        print("Using Cache")
#        with open(last_cache) as fp:
#            return fp.read()
#
#    def search(x, y=None):
#        print("searching: {}".format(x))
#        resp = requests.get('https://oeis.org/search', params={'q': x})
#        html = bs4.BeautifulSoup(resp.text)
#
#        if y and not html.find(text=re.compile(re.escape(y[:10]))):
#            return None
#
#        return html.find('a', text=re.compile('(Table of|Rows )'))
#
#    if seq is not None:
#        a = search('{} "{}"'.format(seq, desc))
#    else:
#        a = search('"{}"'.format(desc))
#        if a is None:
#            a = search(seq, desc)
#
#    if a is not None:
#        print("Found")
#
#    print('Getting https://oeis.org' + a['href'])
#    resp = requests.get('https://oeis.org' + a['href'])
#    if resp.status_code != 200:
#        raise IOError("Not Found")
#    content = resp.text
#    with open(last_cache, "w") as fp:
#        fp.write(content)
#
#    return content
#
#if not os.path.exists('cache'):
#    os.mkdir('cache')
#seq = ''
#try:
#    for question in range(50):
#        print("####### {} #####".format(question))
#        desc = recvline(s).decode()
#        if 'too strange' in desc:
#            print("FAIL: {}".format(line))
#            os.unlink(last_cache)
#            exit(1)
#        if 'Last few ones' in desc:
#            print(desc)
#            continue
#    
#    
#        print(desc)
#        desc = desc.split(':', 1)[1].strip()
#        foo = s.recv(1)
#        if foo != b'n':
#            seq = (foo + recvline(s)).decode()
#            print(seq)
#            seq = seq.split(':')[1].strip()
#    
#            foo = b''
#        else:
#            seq = None
#    
#        line = foo + recvline(s, b"\n:")
#        m = re.search(b'n = (\d+)', line)
#        if m:
#            start = int(m.group(1))
#        else:
#            start = 0
#        print("start = {}".format(start))
#        if b'Answer' not in line:
#            line = recvline(s, b":")
#        m = re.search(b'n = (\d+)', line)
#        if m:
#            n = int(m.group(1))
#            print("n = {}".format(n))
#            if 'The Prime Numbers Revenge' in desc:
#                if n == 23339124:
#                    result = '439770497'
#                elif n == 23339892:
#                    result = '439785523'
#                elif n == 23333893:
#                    result = '439665389'
#                elif n == 23334320:
#                    result = '439674241'
#                else:
#                    result = input()
#            elif 'Catalan num' in desc and n > 1000:
#                result = binomial(2*n, n)//(n+1)
#            elif 'Number of sets of rooted connected graphs where every block is a complete graph.' in desc and n > 200:
#                # TODO
#                pass
#            else:
#                content = getSolutions(seq, desc)
#                off = 0
#                result = None
#                for idx, line in enumerate(content.splitlines(), start):
#                    if line.startswith('#'):
#                        off += 1
#                        continue
#                    current = line.split()
#                    if len(current) > 1:
#                        idx, current = current
#                    elif len(current) == 0:
#                        print(current)
#                        off += 1
#                        continue
#                    else:
#                        idx, current = idx-off, current[0]
#                    if int(idx) == n:
#                        print(line)
#                        result = current.strip()
#                        break
#            print("Result: {}".format(result))
#            s.send("{}\n".format(result).encode())
#finally:
#    for i in range(10):
#        print(recvline(s))
